#!/usr/bin/groovy

@Library('test-shared-library@dai_pipeline') _

import ai.h2o.ci.buildsummary.StagesSummary
import groovy.json.JsonOutput

buildSummary('https://github.com/h2ogpt', true)
buildSummary.get().addStagesSummary(this, new StagesSummary())

def ALL_TESTS = [
        "test_osx_py38":  [ install_deps: ["ALL"],         test_target: "test", node: "osx",     env: ['PYTHON_ENV=/Users/jenkins/anaconda/envs/h2ogpt-py3.10'] ],
        "test_dl17_py38": [ install_deps: ["ALL", "4BIT"], test_target: "test", node: "mr-dl17", env: ['PYTHON_ENV=/home/jenkins/miniconda3/envs/h2ogpt-py3.10'] ],
]

pipeline {
    agent none
    parameters {
        booleanParam(name: 'skipTesting', defaultValue: false, description: 'Skip testing')
        text(name: "testTargets", defaultValue: "${ALL_TESTS.keySet().join('\n')}", description: "A select set of tests to run")
        booleanParam(name: 'publish', defaultValue: false, description: 'Upload to HF')
    }
    options {
        ansiColor('xterm')
        timestamps()
        timeout(time: 60, unit: 'MINUTES')
    }
    stages {
        stage('Build') {
            agent {
                label "linux && docker"
            }
            steps {
                script {
                    sh "make wheel"
                    archiveArtifacts allowEmptyArchive: true, artifacts: "dist/h2ogpt-*.whl"
                    stash includes: "dist/h2ogpt-*.whl", name: "wheel_file"
                }
            }
        }

        stage('Tests') {
            when {
                anyOf {
                    expression { return !params.skipTesting }
                }
                beforeAgent true
            }
            agent {
                label "linux && docker"
            }
            steps {
                script {
                    def test_targets = [:]
                    params.testTargets.split('\n').findAll{ it.contains("test_") }.each { test_name ->
                        test_targets[test_name] = {
                            node("${ALL_TESTS[test_name].node}") {
                                buildSummary.stageWithSummary("${test_name}", "${test_name}") {
                                    buildSummary.setStageUrl("${test_name}")
                                    script {
                                        try {
                                            dir("${test_name}") {
                                                withEnv(ALL_TESTS[test_name].env) {
                                                    deleteDir()
                                                    checkout scm
                                                    unstash "wheel_file"
                                                    sh "rm -rf *.py spaces models"  // force the imports from installed wheel
                                                    sh "make venv"                  // setup empty test env
                                                    ALL_TESTS[test_name].install_deps.each { install_dep ->
                                                        sh "make PYTHON_ENV=${PYTHON_ENV} install-${install_dep}"
                                                    }
                                                    sh "make PYTHON_ENV=${PYTHON_ENV} PYTEST_TEST_NAME=_${test_name} IS_PR_BUILD=${isPrBranch()} BUILD_NUMBER=${env.BUILD_ID} BUILD_BASE_NAME=${env.JOB_BASE_NAME} ${ALL_TESTS[test_name].test_target}"
                                                }
                                            }
                                            archiveArtifacts allowEmptyArchive: true, artifacts: "${test_name}/${test_name}_report.xml"
                                        } finally {
                                            junit testResults: "${test_name}/${test_name}_report.xml", keepLongStdio: true, allowEmptyResults: true
                                        }
                                    }
                                }
                            }
                        }
                    }

                    parallel(test_targets)
                }
            }
        }

        stage('Publish') {
            when {
                anyOf {
                    expression { return params.publish }
                }
                beforeAgent true
            }
            agent {
                label "linux && docker"
            }
            steps {
                script {
                    sh "make IS_PR_BUILD=${isPrBranch()} BUILD_NUMBER=${env.BUILD_ID} BUILD_BASE_NAME=${env.JOB_BASE_NAME} publish"
                }
            }
        }
    }
}

def isPrBranch() {
    return (env.CHANGE_BRANCH != null && env.CHANGE_BRANCH != '') ||
            (env.BRANCH_NAME != null && env.BRANCH_NAME.startsWith("PR-"))
}
